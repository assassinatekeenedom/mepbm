First Path.....


	BEZIER CURVE

	pos[x,y]=A		pos[x,y]=D
	pos[x,y]=B		pos[x,y]=C

moveTo(20,20)
bezierCurveTo(20,100,200,100,200,20)
bezierCurveTo(20,100,200,100,200,20)
bezierCurveTo(20,100,200,100,200,20) 


G(f'(NW, SW, NE, NW).join([x,y])) === even numbers... white ... [+;++;e2]
G(f(N, S, E, W).join([x,y])) === even numbers... white ... [+;++;e2]



	(A^n+A^m)===(A^n+m)===@SQUARE MATRIX ..vs.. @PYTHAGOREAN SQUARE MATRIX 
		(consecutivie counters 'n' and 'm'; vs 'a'+'b'+'c').... 

			of (logical clock [alpha,beta,gamma,delta] signals)

	   
			vs [faces@turn]::[[[A],[B],[C]],[D]
					  (3 'x,y' coordinates @BezierCurve@Native JavaScript


BEZIER == @PATH{startLocationChain,mid1,ctrl1,mid2,mid3,mid4,ctrl2,mid5,endLocationChain}
	var canvas = document.getElementById('myCanvas');
      var context = canvas.getContext('2d');

      context.beginPath();
      context.moveTo(188, 130);
      context.bezierCurveTo(140, 10, 388, 10, 388, 170);
      context.lineWidth = 10;

      // line color
      context.strokeStyle = 'black';
      context.stroke();



    F[m][n] + F[m-1][n-1] = F[m+(n-1)]
		...
    F_{-n} = (-1)^{n+1} F_n.

Thus the bidirectional sequence is

    F-8 	F-7 	F-6 	F-5 	F-4 	F-3 	F-2 	F-1 	F0 	F1 	F2 	F3 	F4 	F5 	F6 	F7 	F8
    -21 	13 	-8 	5 	-3 	2 	-1 	1 	0 	1 	1 	2 	3 	5 	8 	13 	21

"Positive" and "Negative" Language @ Pattern @ Interval....

[[[1],[1]],[[1],[0]]] === [[[@F(n+1){}],[F(n)]],[[F(n)],[F(n-1)]]
				           |	    |
					   |        |
	KEY RECURSIVE FUNCTION ------>toggle()====function(){var backup=toggle;var toggle=function(){toggle=backup;return false;}return true;}


	-----[@synchronize-model::@timestamp]  ... [A][a::xref::b][B] ---- <decoupled>(a*b)<decoupled> ----
	

(a.k.a: SQUARE MATRIX)
 _________
 | 1 | 1 |     
 | 1 | 0 |

Since $1===function(An,m,Am){
		Am = An+m 
}


for any square matrix A ((  SEE ABOVE ))) 


, the following identities can be derived,

    \begin{align} {F_m}{F_n} + {F_{m-1}}{F_{n-1}} &= F_{m+n-1}\\ F_{n+1}F_{m} + F_n F_{m-1} &= F_{m+n}~ . \end{align} 